webapp VIDEO (webapp)

- сделать приложение с использованием NODE.js!!!
- исправить работу индикатора загрузки и импорта данных

============
- исправить парсинг CSV данных из field_data_body.csv
	заменить переносы строк в поле body_value?,
	
	изменить разбивку на строки строки CSV (split) - нужно учитывать что могут быть многострочные поля данных....

https://habrahabr.ru/company/mailru/blog/129476/
т.е. допустимы переводы строк внутри поля. Но такие значения полей должны быть обязательно закавычены,

- ИЗМЕНИТЬ формат данных на html (<tr><td>value1</td><td>value2</td></tr>)

- изменить порядок парсинга:
	не сразу разбивать данные на строки исходя из разделителя перевода строки, а
	- по первой строке определить кол-во и название полей,
	- затем, в цикле, 
	отрезать от строки данных фрагмент, содержащий данные этих полей (ориентироваться на кол-во разделителей полей, запятые)
	- внутри фрагмента определить поля и определить является ли проверяемое поле многострочным 
	(содержимое поля ограничено кавычками).
	- предусмотреть что внутри многострочного поля могут находится разные символы - и кавычки, и перевод строк, совпадающий с разделителем строк

проблемы парсинга многострочных полей в 
field_data_body.csv
field_data_field_filename.csv
field_data_field_roles.csv
field_data_field_subfolder.csv


======= разработать алгоритм импорта данных в indexedDB

- загрузка приложения 
	_runApp() 
	webApp.init()

- выполнение загрузки данных в БД (webApp.db.vars["tables"])
	webApp.db.saveData()
	
	если браузер поддерживает сохранение в локальные хранилища, то 
		- запрос с сервера файла данных (возможно сделать запрос серверного API?)
		- парсим и сохраням данные согласно схеме БД (названия таблиц)
		
	если поддержки нет, то в случае если данные находятся в едином файле 
		*- запрос с сервера файла данных
		*- парсим и сохраням данные согласно схеме БД (названия таблиц)
	*иначе переходим к отображению начальной страницы 
		webApp.app.vars["init_url"]
		webApp.app.urlManager()
			webApp.app.buildPage()
				webApp.db.nodeLoad()
					webApp.draw.wrapContent()

	если на этапе получения данных ( webApp.db.nodeLoad() ) возникает запрос
несуществующей в БД таблицы, то 
	*- запрос с сервера файла данных (определить необходимый URL по имени таблицы, просмотр схемы БД)
	- разбор и сохранение в БД +и локальном хранилище (если есть поддержка)

- сделать парсинг формата HTML (field_data_body.html)
- исправить запрос получения ноды (используются другие поля в случае импорта из SQLite)
------------

при загрузке приложения 
- импорт xml файла с данными таблиц 
(
обнаруживаем отсутствие таблиц в БД ????
и запускаем процесс импорта или
проверяем дату последнего обновления и если файл данных создан позже, то обновляем БД)
- импорт отдельных файлов с данными таблиц в разных форматах (xml, json, csv, html)

при выполнении запроса
- импорт файла с необходимой в данном запросе таблицы и сохранение данных в БД
(необходимо иметь схему данных, где будет указано соответствие таблицы, файла и формата)

- изменить формат на data_url (dataInfo[0]["url"], dataInfo[0]["inputDataFormat"])?????????????
*- перейти на использование другого формата ссылки на данные:
webApp.vars["import"]["data_url"] = "../../projects/webapp_db/db/art.xml"
или
webApp.vars["import"]["data_url"] = {
	"node": "node.csv",
	"node_revision": "node_revision.csv",
	"node_type" : "node_type.csv",

	"field_data_body" : "field_data_body.html",
	"field_data_field_filename" : "field_data_field_filename.csv",
	"field_data_field_img_cover" : "field_data_field_img_cover.csv",
	"field_data_field_roles" : "field_data_field_roles.csv",
	"field_data_field_subfolder" : "field_data_field_subfolder.csv",
	"field_data_field_year" : "field_data_field_year.csv",
	"field_data_field_taxonomy" : "field_data_field_taxonomy.csv",
	"field_data_field_taxonomy_alpha" : "field_data_field_taxonomy_alpha.csv",

	"menu_links" : "menu_links.csv",
	"book" : "book.csv",

	"taxonomy_index" : "taxonomy_index.csv",
	"taxonomy_term_data" : "taxonomy_term_data.csv",
	"taxonomy_term_hierarchy" : "taxonomy_term_hierarchy.csv"
};
