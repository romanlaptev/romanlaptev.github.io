webapp DB (webapp)
  объект, объединяющий контроллер, модель, представление


  app (контроллер)
*при необходимости отобразить на странице блок обращается за данными к модели,
полученные данные передает на вывод в представление
----

  webapp.db (модель)
*- выполнение поисковых запросов на SQL и сохранение их памяти
если для выполнения запроса необходимо дополнительно загрузить файлы,
модель обращается к контроллеру
(
*использовать простые запросы к одной таблице или добавить поддержку сложных, составных запросов???
)

  - добавить использование схемы при парсинге XML-документа
(для форматов JSON, CSV необходимо вручную составлять схему данных...)  
	- получение данных происходит из - 
	1) indexedDB, 2) webSQL, 3) Localstorage 
	4)путем выполнения запросов к серверному API

----

  webapp.draw (представление)
- на основе результатов запроса генерирование html-блоков
(модуль получает данные из модели) 
настройки блоков также хранятся в модели, в соотв. таблице
модуль выводит переданные данные в указанный блок разметки - аргументы data, id
*- считать соответв. шаблон блока (скрипт типа template), 
заполнить данными и вставить в разметку, туда, где определен этот шаблон
(нужно отделять разметку страницы от шаблонов!!!!, шаблоны в отдельном файле...)

---- SERVER
- необходимо определять тип веб сервера (Apache, IIS )
- определять OS сервера (windows, linux, mac )
- необходимо добавить возможность работы с удаленной mySQL базой, Oracle, msSQL....
- необходимо определять доступные языки программирования на сервере (PERL, *PHP, ASP, *ASP.NET, Python)
- в случае недоступности серверных языков программирования использовать CGI-скрипты
- если сервер не подерживает выполнение серверных скриптов, то загружать файл данных без проверки даты последнего обновления

- загрузка или обновление данных в БД (webApp.db.loadData)
	- при старте приложения запрос на сервер с датой последнего обновления 
	(не текущая дата обновления, а дата  создания файла данных с обновлением!!!!)
	- ответ сервера зависит от сравнения дат: дата последнего обновления клиента и дата формирования файла данных
	- если в ответе содержатся данные, то загрузить их в модель (или вначале в indexedDB, webSQL, localStorage)

на сервере происходит сравнение полученной от клиента даты и даты файла с актуальными данными,
если совпадают, то возвращается пустой ответ,
если дата клиента раньше даты файла или клиент не передал дату, 
то возвращаются данные файла + новая дата файла данных которая сохраняется в idb_master
	
вариант проще 
- хранить дату создания файла с выгрузкой из БД в самом файле и при старте приложения 
сравнивать ее с датой клиента. Недостаток - нужно полностью закачивать весь файл данных 
при каждом старте, 
- чтобы избежать этого нужно создать и поддерживать дополнительный 
небольшой xml, json файл с датой создания файла выгрузки и запрашивать его при старте приложения.
Затем, в зависимости от результата сравнения дат выполнить загрузку файла со всеми данными или продолжить
использовать данные из хранилища

также можно использовать HEAD-запрос для art.xml
Accept-Ranges	bytes
Access-Control-Allow-Orig...	*
Content-Length	1592201
Content-Type	text/xml
Date	Thu, 10 Aug 2017 07:30:23 GMT
Etag	"1de7e0a6bee4d21:0"
Last-Modified	Wed, 14 Jun 2017 03:31:04 GMT!	!!!!!!!
Server	Microsoft-IIS/7.5
X-Powered-By	ASP.NET


----
*- необходимо определять время *генерации блока, *выполнения запроса, *генерации страницы

*- доработать функцию _query для обработки запросов с подзапросами нескольких уровней вложенности
происходит неверное определение baseQuery в момент подстановки в основной запрос
результатов subQuery. 
В качестве baseQuery всегда используется самый первый родительский запрос options["queryObj"],
хотя нужно менять baseQuery в зависимости от subQuery. 
baseQuery содержит  subQuery (один или несколько) на одном уровне вложенности

- выяснить, где в БД находится информация о блоках страницы
SELECT * FROM `blocks` WHERE `theme` = 'pushbutton' AND `status` =1

------- SELECT * FROM `blocks` WHERE `theme` = 'pushbutton'
bid	252
module	views
delta	info_termins_style-block_1
theme	pushbutton
region	left
status	1

--------- SELECT * FROM `views_view`
vid	22
name	info_termins_style
base_table	term_data


-------- SELECT * FROM `views_display` WHERE `vid` =22
vid	22
id	block_1

vid	22
id	default
display_options 	
a:14:{
	s:13:"relationships";
	a:1:{
			s:6:"parent";
			a:3:{
					s:2:"id";
					s:6:"parent";
					s:5:"table";
					s:14:"term_hierarchy";
					s:5:"field";
					s:6:"parent";
				}
		}
и т.д, т.е. параметры представления info_termins_style

BLOCKS
- видимость блоков на странице зависит от параметра opt["visibility"] = "список страниц для вывода блока"

ШАБЛОНЫ
- шаблоны хранятся в отдельных файлах
- в случае необходимости подгружаются через аякс-запросы
- необходима возможность загружать ресурсы (БД, шаблоны) со стороннего домена через AJAX
page.tpl - шаблон всей страницы, включая область контента
node.tpl - шаблон области контента
block.tpl - стандартный шаблон блока


NODE
- при выводе на страницу контента страниц (node) нужно применять шаблон node.tpl с возможностью его переопределения
- разработать и применить запрос на получение контента страницы из node, node_revision
также подключить информацию о связанных терминах ноды


VIEWS
- формировать запросы на получение данных...
- запросы хранятся в отдельном json
- считывать запросы в webApp.app.vars["queries"]....
- каждый запрос имеет уникальное имя


ЭКСПОРТ/ИМПОРТ
- загрузка данных таблиц СМС в *память или в indexedDB, webSQL (входные данные в форматах *XML, *JSON, *CSV)
для форматов JSON, CSV нужно сделать отдельный экспорт из MySQL, 
	варианты экспорта
		- таблицы в файле экспорта отделяются друг от друга
		- для CSV используется разделение на блоки внутри файла данных 
		#HEAD { "name" : "term_hierarchy", "fields" : ["tid","parent"]}		
		
- конвертировать входные данные во внутренний формат хранения данных: JSON
(сделать для всех форматов *XML, *JSON, *CSV)

- при импорте в JSON, CSV исправить ошибки из-за запятых, кавычек в тексте полей

- изменить запуск процесса импорта (webApp.db.loadData):
	при старте приложения,
	также при нажатии на кнопку Import

- *сделать окно ожидания для запросов и вывод прогресса аякс-запроса

================= необходимый API
- сформировать разметку страницы, блок контента + блоки сайдбаров, подвала и заголовка (app.buildPage)
- сформировать блок (app.buildBlock)


- МАТЕРИАЛЫ
( 
- получение произвольной ноды по ид (db.nodeLoad), 
по типу, по заголовку, по алиасу
- получение прикрепленных к ноде полей (контент, файлы, изображения, комментарии)
__getBody(nid, callback)

- получение терминов, связанных с нодой
- получение алиаса ноды по ид (__getUrlAlias)
- пагинация для больших списков
)

- ТАКСОНОМИЯ
(
- получения всего словаря по ид, по названию (db.getVocabularyByName)
- получение термина по имени из указанного словаря (db.getTermByName)
- получение дочерних терминов указанного термина (db.getChildTerms)
- получение нод связанных с указанным термином ( db.getTerminNodes )
- пагинация для больших списков
)
- ПОДШИВКИ
(
	получение списка книг, 
	получение отдельной книги со страницами
	формирование ссылок навигации по страницам
)

- БЛОКИ (
	получить список блоков, 
	получить отдельный блок с его параметрами
	добавить в разметку страницы код блока (draw.insertBlock)
)
- строка навигации, хлебные крошки

- сделать отдельные шаблоны (node.html, book.html) или 
использовать urlManager с обработчиками событий кликов
	
- URLMANAGER
	- разбор строки url (GET запрос) на переменные и значения
	- в зависимости от значения переменной "q" формировать контентный блок страницы
	(
q=node&nid=1 - показать ноду с ид 1
q=taxonomy&term=105  - показать список нод связанных с термином "модерн"
q=book&bid=...показать подшивку
	)
	- сделать обработку внутренних ссылок (#clear-log.....)
	

=============== CSS
- сделать верстку для работы с приложением на мобильных телефонах, планшетах
(изменение выравнивания сайдбаров, уменьшение блоков боковых панелей до заголовка)
